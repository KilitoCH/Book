# CSS基础

## CSS选择器
* 使用元素名，例如`p,header`。示例：
```css
p {
    font-size: 10px;
}
```
如果只想选取某个特定位置元素可以用他的父元素嵌套来指定，例如：`p em`。即会选取段落中的`em`元素。
* 使用类名。使用类名只需要在类名前加上一个`.`。如果想要用类名筛选时只选取某种元素，可以类似这样：`li.aClass`。
* css中还提供了一种相邻选择符`+`。可以指定某元素和它的下一个元素的样式，而不影响其他的。例如：`h1 + p`。 就只会影响这相邻的两个元素。
* 根据状态确定样式。比如是否是未访问过的、访问过的、被鼠标悬停的等等。例如：
```css
a:link {
    color: pink;
}

a:visited {
    color: green;
}
上述代码会使得链接在访问前为粉色，点击后变成绿色。
```

### CSS的三种使用形式

|    类型    |                                   描述                                    |                                           优劣                                           |
| :--------: | :-----------------------------------------------------------------------: | :--------------------------------------------------------------------------------------: |
| 外部样式表 | 构建单独的css样式表，然后在html文档的head部分使用`<link>`引用这个样式表。 |            推荐使用，易于维护，一次开发多次引用。加载页面快（先不加载css）。             |
| 内部样式表 |       不使用单独的css文件，而是将css放在head标签的`<style>`标签中。       |                            不利于多文档复用，加载时速度较慢。                            |
|  内联样式  |                   直接在元素中以`<style>`标签添加样式。                   | 最不推荐使用的一种，一旦需要维护需要一个个元素修改。只在特别需要考虑兼容性的时候才使用。 |

### CSS的应用层次
**CSS**：Cascading Style Sheet（层叠样式表）。
由于css的机制，我们经常会在很多地方定义同一个元素的样式，这时候就涉及到取舍问题。所以在css中存在着“谁生效”的问题。

* **层叠** css的顺序可以决定css的应用情况。当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。

* **优先级** 不同的元素选择器具有不同的优先级。例如元素选择器（不够具体）的优先级就低于类选择器。 

* **继承** 某些设置在父元素上的css属性是可以被子元素继承的，有些则不能。例如颜色、字体等就可以。例如设置文档的`body`的字体颜色，会导致所有正文部分的字体颜色都被设置。但是有些例如宽度属性就不会被继承。

* **控制继承** CSS为控制继承提供了四个特殊通用属性值。每个属性都会接收这些值。

| 属性值  |                                                  效果                                                   |
| :-----: | :-----------------------------------------------------------------------------------------------------: |
| inherit |                     设置该属性会使子元素属性和父元素相同。实际上，就是 "开启继承"。                     |
| initial | 设置属性值和浏览器默认样式相同。如果浏览器默认样式中未设置且该属性是自然继承的，那么会设置为 inherit 。 |
|  unset  |            将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial一样.            |

在css中有一个属性`all`，通过将这个属性设置为上述值，可以同时应用或者撤销这个元素的几乎所有属性。

### css选择器参考表

[css选择器参考表](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors#%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%82%E8%80%83%E8%A1%A8)

### 盒模型

在CSS中有块级盒子(Block box)和内联盒子(Inline box)区别。我们可以通过设置`display`属性为"inline"或"block"来控制盒子的外部显示类型。控制外部显示类型为块级或内联，会改变它与布局中的其他元素的显示方式。

#### 块级盒子（标准盒模型）
* 每个盒子都会换行，例如`<h1>`和`<p>`和`<div>`等都是块级盒子。
![块级盒子模型](../../Assets/figure/box-model.png)

- 标准的盒子模型由上述图片所表示，包含四个部分：
    - Content Box，通过高宽来设置。
    - Padding 是包含在上述内容区域外部的空白区，可以通过`padding`相关属性设置。
    - Border Box 即包含在padding外部的边框。
    - Margin Box 是盒子和其他元素之间的空白区域。通过margin相关属性设置。

- 在标准盒模型中，设置宽高实际设置的是Content的宽高。再加上"padding""Border"两个部分构成整个盒子的大小。"margin"不计入盒子的大小，但是会影响其在页面中实际占用的面积。
- **替代盒模型** 上述盒子大小由三个部分构成，设置的时候需要考虑三者之和，这比较麻烦。所以css还有一个替代盒模型，设置宽高将直接设置上述三者之和，即直接设置“可见宽高”。代码示例：
    ```css
    .box {
        box-sizing: border-box;
    }
    ```
    如果需要设置全局均为替代模式，可以在html元素上设置。示例代码：
    ```css
    html {
        box-sizing: border-box;
    }
    * ,*::before,*::after {
        box-sizing: inherit;
    }
    ```
- **外边距折叠** 当两个元素相邻时，他们的间距将取决于较大的外边距，而非两者之和。

#### 使用`display: inline-block`
这是一种介于内联盒子和块级盒子中间的状态，它将不会换行，但是也不会如同内联盒子一样无法设置宽高导致元素重叠。设置这种属性的盒子的宽高将使得元素所在行高度发生变化。

### 背景
背景可以使用纯色、渐变色、图片进行填充。[参考链接](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Backgrounds_and_borders#css%E7%9A%84%E8%83%8C%E6%99%AF%E6%A0%B7%E5%BC%8F)

### CSS的值与单位

#### 长度
* 绝对长度单位，例如cm,mm,px（像素）等。最常用的应该是像素，其他单位则在界面上不太好用。
* 相对长度单位，相对于其他元素设定大小。常用单位为`em`。在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。总之就是相对字体的大小。相对应的`rem`则是相对于根元素的字体大小。
* `vh`和`vm`，对应视窗高度和视窗宽度，相较于`100%`这样的表示方法而言要更加明确（有时候找不到父元素，不知道100%对应谁。）

#### 颜色
* `#ffffff`#后面依次表示rgb通道。
* `rgb`和`rgba`。也是用三个通道表示颜色，区别在于上面用十六进制表示，这里用十进制表示。`rgba`中的a表示不透明度，这只用于控制颜色的不透明度，对元素的其他部分不影响。

#### 相对值
* 百分比，一般相对父元素。
  * 有时候设置100%会没有作用，这是因为父元素没有相关值设置，所以100%计算无效。
* max/min，如字面值。

## Grid布局

网格布局即将页面划分为不同大小的许多网格，且我们可以定义他们之间的间距，这就像拼积木一样，利与进行排布。

### 定义一个网格
* 首先我们需要声明一个父组件为网格布局，这样他的所有子组件都会按照网格布局排布。声明代码：
  ```css
    .container {
        display: grid;
    }
  ```
* 定义网格布局之后，我们需要声明新的行列，在创建的时候我们就可以指定行列的宽度。示例代码：
  ```css
    .container {
        display: grid;
        grid-template-columns: 200px 1fr 1fr;//这里定义三列的宽度即是创建三列，且设定第一列宽度为200px固定宽度。后两列则会为总宽度减去第一列之后1：1分配剩下的。
    }
  ```
  > **注：** `fr`单位用于定义相对值，即几个元素分别占总的的比例，可以用于定义占用剩下部分的比例，而不一定为总的。
* **网格间隙** 使用`grid-column-gap`和`grid-row-gap`来定义列间隙和行间隙。使用`grid-gap`可以同时设定行列间隙。设置的值可以使用固定单位或比例，但是不能用fr这种相对单位。
* `minmax()`函数，用于定义元素占用的部分的最大最小值。
* `grid-template-areas`属性，这个属性可以直接强制指定元素在网格中占用哪些格子，如果需要一个元素占用连续多格，只需要重复书写一遍即可。代码示例：
  ```css
    .container {
        display: grid;
        grid-template-areas:
            "header header"
            "sidebar content"
            "footer footer";
        grid-template-columns: 1fr 3fr;
        grid-gap: 20px;
    }

    header {
        grid-area: header;
    }

    article {
        grid-area: content;
    }

    aside {
        grid-area: sidebar;
    }

    footer {
        grid-area: footer;
    }
  ```

## 浮动
设置元素的`float`属性为`left,right`等可以使元素浮动内嵌进文本中。
* 设置`clear`属性可以设置元素不再浮动。有三个可设置的值。

    | 属性值 |          含义          |
    | :----: | :--------------------: |
    |  left  |  停止任何活动的左浮动  |
    | right  |  停止任何活动的右浮动  |
    |  both  | 停止任何活动的左右浮动 |
> 更多内容参见[mdn文档](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Floats)
## 定位*

**文档流** 默认的布局样式为盒布局，即默认的显示方式为`display: block;`。这样会使得整个布局沿着纵向以一个个盒子的方式排布。而内联样式`display: inline;`则会使得元素填充在同一行中。所以除了上述的`flex`布局和`grid`布局之外，我们需要采取其他的定位方式。
**使用定位** 使用`position`属性
* 静态定位，设定`position: static;`，即是默认的定位。在流式布局中保持元素原本的位置。
* 相对定位，设定`position: relative;`，这样我们需要设置元素的定位方式为`top,left`等，并设定一个值，相当于施加一个“推力”，让元素以设定值远离这个边界。
* 绝对定位，设定`position: absolute;`，这样他们会无视其他元素，假装这个父组件中只有自己。仍可指定他相对父元素的位置，但是其他元素已经没办法对他们产生影响。
* `z-index`属性，当元素重叠之后我们可以通过设定这个“相对值”来控制这些元素的相对层叠顺序。他们的层叠次序只取决于值的相对大小。
* 固定定位，设定`position: fixed;`，这与绝对定位的区别为绝对定位是相对父组件。但是固定定位是相对与整个页面，也就是相对于`html`根元素。这样再设定其位置时就会绝对固定。可以用这种方式固定导航栏等。
* 还有一种很神奇的方式，设定`position: sticky;`，可以使元素贴在屏幕上的固定位置。当元素尚未到达设定位置时他很像一个相对定位元素。但是当元素到达时其将变为固定位置。[参考位置](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Positioning#position_sticky)那么吧v和将很快n'h'j'k'm'n'm'h'jnhjkmnmhj    